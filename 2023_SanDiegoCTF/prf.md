# Lake of Pseudo-Random Fire

Cryptography, 300 pts

> Greetings! You are a weary traveller, searching for a long-lost treasure - the Beacon of True Randomness. However, in your quest to obtain it, you must go through a series of rooms to get to the Beacon. In each room there are two doors - one leads you closer to the Beacon, but the other leads to Lake of Pseudo-Random Fire - your demise! Accompanying you in your journey is a high priest named Orycull. They are your only way to tell which door is which. When Orycull utters an incantation of your choosing, the doors emit different signals. The door leading you closer to the Beacon will emit a fully random signal, while the door leading you to the Lake will emit a pseudorandom signal. A clever traveller may be able to distinguish the random and pseudorandom signals and safely get to the treasure. However, be careful as Orycull can only utter so many incantationsâ€¦

## Analysis

The game gives us 50 stages and 2 doors on each stage. Along with the doors, there is Orycull, who can give out at most 100 hints. We can input a 16-byte hexstring, and each door returns a 32-byte hexstring. One of the doors returns a truly random hexstring, the other returns a concatenated string generated by AES ECB. 

This means that when I input, for example, hexstring `0x00000000000000000000000000000000`, the pseudo-random door will return a hexstring with the last 16 bytes being a decryption of the message `0xffffffffffffffffffffffffffffffff`. This means when I take those last 16 bytes as input for another hint, the pseudo-random door will the return `0xffffffff...`. However, this takes at least 2 hints, and only one of the two doors will be pseudo-random, which means at most 3 hints will be used. To blindly choose the correct door each time for testing has the same probability as flipping heads 50 times in a row. 

However, I realised that there is no need to correctly choose the pseudo-random door each time. If I just choose the left door for testing each time, then if it is the pseudo-random door, it will return `0xff...` on the second hint. If not, then it will return gibberish.

## Methodology

Now that I have analysed the game, I would want to write a program to automate going through all the 50 doors for me. The process is as follows: 

1. Connect to the remote server.
1. For each stage, first use a hint, and send hexstring full of `0x00`s.
1. Get the return value on the left door, take the last 16 bytes.
1. Use the second hint, input previous bytes.
    * If the left door returns random bytes, it's the random door.
    * If the left door returns `0xffff...`, it's the pseudo-random door.
1. Choose the random door and proceed.

The script is written in Python with `pwntools` to do the receiving and sending of data.

## The script

The script is available separately on my writeups repo.

```python
from pwn import *
import re


def solve():
    ff_string = b"f" * 32

    p = remote("prf.sdc.tf", 1337)

    doors = 50
    while doors > 0:
        p.recvuntil(b"Enter a number: ")
        p.sendline(b"3")
        p.sendline(b"0" * 32)

        left_door = p.recvline().decode("utf-8")
        test_hex = re.findall("[0-9a-f]{64}", left_door)[0]
        ff_part = test_hex[32:]

        p.recvuntil(b"Enter a number: ")
        p.sendline(b"3")
        p.sendline(ff_part.encode())

        result = p.recvline().decode("utf-8")
        result_hex = re.findall("[0-9a-f]{64}", result)[0]

        p.recvuntil(b"Enter a number: ")

        if ff_string.decode("utf-8") in result_hex:
            p.sendline(b"2")
        else:
            p.sendline(b"1")

        doors -= 1

    for _ in range(5):
        print(p.recvline())


if __name__ == "__main__":
    solve()
```

When it's all done, the flag is outputted to the console.

`sdctf{n07_V3rY_pS3uD0R4nD0m_a6d137}`